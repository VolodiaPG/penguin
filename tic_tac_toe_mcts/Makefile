#
# Env variables
#
# TODO make it works outside docker !
ENV_EMSCRIPTEN_FASTCOMP := /home/vagrant/emsdk/fastcomp/emscripten

#
# Default variables
#

# emscripten ...
TARGET_ENV ?= -
# debug, release ...
BUILD_ENV ?= -

DOXYGEN := doxygen
DOXYGEN_FLAGS := 

#
# Compiler files
#

ifeq ($(TARGET_ENV),emscripten)
CC := $(ENV_EMSCRIPTEN_FASTCOMP)/em++
# EXECUTABLE_C_FLAGS := -s ERROR_ON_UNDEFINED_SYMBOLS=0 -s WASM=1
# C_FLAGS := -Wno-dollar-in-identifier-extension --bind
EXECUTABLE_C_FLAGS := -s NO_EXIT_RUNTIME=1 -s EXPORTED_FUNCTIONS="['_main', '_initGame', '_deleteGame' ,'_play', '_mctsResult', '_checkStatus', '_getPlayerToPlay']" -s EXTRA_EXPORTED_RUNTIME_METHODS="['cwrap', 'ccall']"
C_FLAGS := -s ASSERTIONS=2 -s WASM=1
endif

ifeq ($(TARGET_ENV),-)
# C_FLAGS := `sdl2-config --cflags --libs`
C_FLAGS := 
CC := g++
endif


EXECUTABLE_C_FLAGS ?= 
C_FLAGS += -std=c++17 -Wall -Wextra -pedantic -pedantic-errors -Werror -pthread #-lstdc++

#c
# Project files
#
BIN		:= bin
SRC		:= src
INCLUDE	:= include
LIB		:= lib
WWW		:= www
DOC     := doc
SERVE   := $(BIN)/served

LIBRARIES	:=

#
# Final exe file
#
ifeq ($(TARGET_ENV),emscripten)

EXECUTABLE  := $(WWW)/main.html

else

ifeq ($(OS),Windows_NT)
EXECUTABLE	:= main.exe
else
EXECUTABLE	:= main
endif

endif

#
# Release build settings
#
release :C_FLAGS += -O3
REL_DIR    := release

#
# Debug build settings
#
debug :C_FLAGS += -g -O0 
DBG_DIR    := debug

#
# Definition of build environement, choosing what target you want: release, debug, ... (not to be definied here but rather passed when executing the command make)
#
# BUILD_ENV=release

#
# Definition of makefile's working dirs 
# Specify an envionement to create the named speratee folder in the bin folder
#
ifneq ($(BUILD_ENV),-)
BINARIES := $(BIN)/$(BUILD_ENV)
endif

BINARIES ?= $(BIN)

#
# Objects
#
# $(wildcard $(SRC)/*.hpp) is replaced by a space-separated list of names of existing files that match one of the given file name patterns. 
# $(patsubst pattern,replacement,$(var))
OBJECTS := $(patsubst $(SRC)/%.cpp, $(BINARIES)/%.o, $(wildcard $(SRC)/*.cpp))

#
# Commands that are phony (not files)
#
.PHONY: clean prep serve doc

#
# Default build
#
all: build

#
# Build rules
#
build: prep ./$(BINARIES)/$(EXECUTABLE)

$(BINARIES)/$(EXECUTABLE): $(OBJECTS)
	$(CC) $(C_FLAGS) $(EXECUTABLE_C_FLAGS) -I$(INCLUDE) -L$(LIB) $^ -o $@ $(LIBRARIES)

$(BINARIES)/%.o: $(SRC)/%.cpp
	@$(CC) $(C_FLAGS) -I$(INCLUDE) -L$(LIB) -c $< -o $@ $(LIBRARIES)

$(BINARIES)/%.o: $(SRC)/%.cpp $(SRC)/%.hpp
	@$(CC) $(C_FLAGS) -I$(INCLUDE) -L$(LIB) -c $< -o $@ $(LIBRARIES)

#
# Debug rules
#
ifeq ($(TARGET_ENV),emscripten)
debug: build link_bin
else
debug: build
endif

dbg_run: debug
	./$(BINARIES)/$(EXECUTABLE)

#
# Release rules
#
ifeq ($(TARGET_ENV),empscripten)
release: build link_bin
else
release: build
endif

rel_run: release
	./$(BINARIES)/$(EXECUTABLE)

#
# Other rules
#

ifeq ($(TARGET_ENV),emscripten)
doc: doc_common link_doc
else
doc: doc_common
endif

doc_common: prep	
	$(RM) -r ./$(DOC)/$(DOXYGEN)/*
	cd $(DOC)/ && $(DOXYGEN) $(DOXYGEN_FLAGS)

#
# Other rules
#
clean:
	$(RM) -r $(BIN)/*

ifeq ($(TARGET_ENV),emscripten)

# Create dirs and recursively hardlink files
prep: prep_common
	mkdir -p $(BINARIES)
	mkdir -p $(BINARIES)/$(WWW)/
	mkdir -p $(DOC)/$(DOXYGEN)
	mkdir -p $(SERVE)/$(WWW)
	mkdir -p $(SERVE)/$(DOC)

link_doc:
	$(RM) -r ./$(SERVE)/$(DOC)/* && \
	touch ./$(DOC)/$(DOXYGEN)/html/*
	cp -af ./$(DOC)/$(DOXYGEN)/html/* ./$(SERVE)/$(DOC)/

link_bin:
	$(RM) -r ./$(SERVE)/$(WWW)/*
	touch ./$(WWW)/*
	cp -af ./$(WWW)/* ./$(SERVE)/$(WWW)/
	touch ./$(BINARIES)/$(WWW)/*
	cp -af ./$(BINARIES)/$(WWW)/* ./$(SERVE)/$(WWW)/

serve: build doc link_bin link_doc
	cd $(SERVE) && python -m SimpleHTTPServer 8080

else
prep: prep_common
endif

prep_common:
	mkdir -p $(BINARIES)
	mkdir -p $(DOC)/$(DOXYGEN)

run: all
	./$(BINARIES)/$(EXECUTABLE)

